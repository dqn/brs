/// Integration tests for decoding real audio files.
///
/// Tests all supported formats with 440Hz sine wave test files
/// generated by ffmpeg (0.5 seconds each).
use std::path::{Path, PathBuf};

use bms_audio::decode;
use bms_audio::pcm::Pcm;

fn test_audio_dir() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("..")
        .join("..")
        .join("test-bms")
        .join("audio")
}

/// Verify basic PCM properties after decoding.
fn assert_pcm_basic(pcm: &Pcm, expected_channels: u16, expected_sample_rate: u32, label: &str) {
    assert!(pcm.validate(), "{label}: PCM should be valid");
    assert_eq!(
        pcm.channels, expected_channels,
        "{label}: channels mismatch"
    );
    assert_eq!(
        pcm.sample_rate, expected_sample_rate,
        "{label}: sample_rate mismatch"
    );
}

/// Verify that samples are within valid range.
///
/// Allows small overshoot due to i16::MIN / i16::MAX = -1.0000305.
fn assert_samples_in_range(pcm: &Pcm, label: &str) {
    let tolerance = 1e-3;
    for (i, &s) in pcm.samples.iter().enumerate() {
        assert!(
            s >= -1.0 - tolerance && s <= 1.0 + tolerance,
            "{label}: sample[{i}] = {s} out of range [-1.001, 1.001]"
        );
    }
}

/// Verify that the PCM contains a recognizable sine wave.
///
/// Checks that:
/// - There are both positive and negative samples (not silence)
/// - The peak amplitude is reasonable (> 0.5)
fn assert_sine_wave_like(pcm: &Pcm, label: &str) {
    let max = pcm
        .samples
        .iter()
        .cloned()
        .fold(f32::NEG_INFINITY, f32::max);
    let min = pcm.samples.iter().cloned().fold(f32::INFINITY, f32::min);

    assert!(
        max > 0.5,
        "{label}: max sample {max} too low for a sine wave"
    );
    assert!(
        min < -0.5,
        "{label}: min sample {min} too high for a sine wave"
    );
}

// --- WAV PCM 16-bit ---

#[test]
fn test_decode_wav_16bit_mono() {
    let path = test_audio_dir().join("sine_440_16bit_mono.wav");
    let pcm = decode::load_audio(&path).expect("Failed to decode WAV 16-bit mono");

    assert_pcm_basic(&pcm, 1, 44100, "WAV 16-bit mono");
    assert_samples_in_range(&pcm, "WAV 16-bit mono");
    assert_sine_wave_like(&pcm, "WAV 16-bit mono");

    // 0.5s at 44100Hz = 22050 frames (trailing silence stripped, so <= 22050)
    let frames = pcm.num_frames();
    assert!(
        frames > 20000 && frames <= 22050,
        "WAV 16-bit mono: expected ~22050 frames, got {frames}"
    );
}

#[test]
fn test_decode_wav_16bit_stereo() {
    let path = test_audio_dir().join("sine_440_16bit_stereo.wav");
    let pcm = decode::load_audio(&path).expect("Failed to decode WAV 16-bit stereo");

    assert_pcm_basic(&pcm, 2, 44100, "WAV 16-bit stereo");
    assert_samples_in_range(&pcm, "WAV 16-bit stereo");
    assert_sine_wave_like(&pcm, "WAV 16-bit stereo");

    let frames = pcm.num_frames();
    assert!(
        frames > 20000 && frames <= 22050,
        "WAV 16-bit stereo: expected ~22050 frames, got {frames}"
    );
    // Stereo: total samples = frames * 2
    assert_eq!(pcm.samples.len(), frames * 2);
}

#[test]
fn test_decode_wav_8bit_mono() {
    let path = test_audio_dir().join("sine_440_8bit_mono.wav");
    let pcm = decode::load_audio(&path).expect("Failed to decode WAV 8-bit mono");

    assert_pcm_basic(&pcm, 1, 22050, "WAV 8-bit mono");
    assert_samples_in_range(&pcm, "WAV 8-bit mono");
    assert_sine_wave_like(&pcm, "WAV 8-bit mono");

    // 0.5s at 22050Hz = 11025 frames
    let frames = pcm.num_frames();
    assert!(
        frames > 10000 && frames <= 11025,
        "WAV 8-bit mono: expected ~11025 frames, got {frames}"
    );
}

#[test]
fn test_decode_wav_24bit_mono() {
    let path = test_audio_dir().join("sine_440_24bit_mono.wav");
    let pcm = decode::load_audio(&path).expect("Failed to decode WAV 24-bit mono");

    assert_pcm_basic(&pcm, 1, 48000, "WAV 24-bit mono");
    assert_samples_in_range(&pcm, "WAV 24-bit mono");
    assert_sine_wave_like(&pcm, "WAV 24-bit mono");

    // 0.5s at 48000Hz = 24000 frames
    let frames = pcm.num_frames();
    assert!(
        frames > 22000 && frames <= 24000,
        "WAV 24-bit mono: expected ~24000 frames, got {frames}"
    );
}

#[test]
fn test_decode_wav_float32_mono() {
    let path = test_audio_dir().join("sine_440_float32_mono.wav");
    let pcm = decode::load_audio(&path).expect("Failed to decode WAV float32 mono");

    assert_pcm_basic(&pcm, 1, 44100, "WAV float32 mono");
    assert_samples_in_range(&pcm, "WAV float32 mono");
    assert_sine_wave_like(&pcm, "WAV float32 mono");

    let frames = pcm.num_frames();
    assert!(
        frames > 20000 && frames <= 22050,
        "WAV float32 mono: expected ~22050 frames, got {frames}"
    );
}

#[test]
fn test_decode_wav_msadpcm_mono() {
    let path = test_audio_dir().join("sine_440_adpcm_mono.wav");
    let pcm = decode::load_audio(&path).expect("Failed to decode WAV MS-ADPCM mono");

    assert_pcm_basic(&pcm, 1, 44100, "WAV MS-ADPCM mono");
    assert_samples_in_range(&pcm, "WAV MS-ADPCM mono");
    assert_sine_wave_like(&pcm, "WAV MS-ADPCM mono");

    // MS-ADPCM may have slightly different frame count due to block alignment
    let frames = pcm.num_frames();
    assert!(
        frames > 20000 && frames <= 23000,
        "WAV MS-ADPCM mono: expected ~22050 frames, got {frames}"
    );
}

// --- FLAC ---

#[test]
fn test_decode_flac_mono() {
    let path = test_audio_dir().join("sine_440_mono.flac");
    let pcm = decode::load_audio(&path).expect("Failed to decode FLAC mono");

    assert_pcm_basic(&pcm, 1, 44100, "FLAC mono");
    assert_samples_in_range(&pcm, "FLAC mono");
    assert_sine_wave_like(&pcm, "FLAC mono");

    // FLAC is lossless: should match WAV frame count exactly
    let frames = pcm.num_frames();
    assert!(
        frames > 20000 && frames <= 22050,
        "FLAC mono: expected ~22050 frames, got {frames}"
    );
}

// --- OGG Vorbis ---

#[test]
fn test_decode_ogg_mono() {
    let path = test_audio_dir().join("sine_440_mono.ogg");
    let pcm = decode::load_audio(&path).expect("Failed to decode OGG Vorbis mono");

    assert_pcm_basic(&pcm, 1, 44100, "OGG mono");
    assert_samples_in_range(&pcm, "OGG mono");
    assert_sine_wave_like(&pcm, "OGG mono");

    // OGG Vorbis is lossy: frame count may vary slightly
    let frames = pcm.num_frames();
    assert!(
        frames > 18000 && frames <= 24000,
        "OGG mono: expected ~22050 frames, got {frames}"
    );
}

// --- MP3 ---

#[test]
fn test_decode_mp3_mono() {
    let path = test_audio_dir().join("sine_440_mono.mp3");
    let pcm = decode::load_audio(&path).expect("Failed to decode MP3 mono");

    assert_pcm_basic(&pcm, 1, 44100, "MP3 mono");
    assert_samples_in_range(&pcm, "MP3 mono");
    assert_sine_wave_like(&pcm, "MP3 mono");

    // MP3 has encoder padding, so frame count may be higher
    let frames = pcm.num_frames();
    assert!(
        frames > 18000 && frames <= 25000,
        "MP3 mono: expected ~22050 frames, got {frames}"
    );
}

// --- Cross-format consistency ---

#[test]
fn test_lossless_formats_consistency() {
    let wav_path = test_audio_dir().join("sine_440_16bit_mono.wav");
    let flac_path = test_audio_dir().join("sine_440_mono.flac");

    let wav_pcm = decode::load_audio(&wav_path).expect("Failed to decode WAV");
    let flac_pcm = decode::load_audio(&flac_path).expect("Failed to decode FLAC");

    // Both are lossless from the same source, so frame counts should match
    assert_eq!(
        wav_pcm.num_frames(),
        flac_pcm.num_frames(),
        "WAV and FLAC frame counts should match"
    );

    // Sample values should be very close (both 16-bit precision)
    let max_diff: f32 = wav_pcm
        .samples
        .iter()
        .zip(flac_pcm.samples.iter())
        .map(|(a, b)| (a - b).abs())
        .fold(0.0f32, f32::max);

    assert!(
        max_diff < 0.001,
        "WAV and FLAC samples should be nearly identical, max_diff = {max_diff}"
    );
}

// --- load_audio dispatch ---

#[test]
fn test_load_audio_dispatch_all_formats() {
    let dir = test_audio_dir();
    let files = [
        ("sine_440_16bit_mono.wav", 1u16, 44100u32),
        ("sine_440_16bit_stereo.wav", 2, 44100),
        ("sine_440_8bit_mono.wav", 1, 22050),
        ("sine_440_24bit_mono.wav", 1, 48000),
        ("sine_440_float32_mono.wav", 1, 44100),
        ("sine_440_adpcm_mono.wav", 1, 44100),
        ("sine_440_mono.flac", 1, 44100),
        ("sine_440_mono.ogg", 1, 44100),
        ("sine_440_mono.mp3", 1, 44100),
    ];

    for (file, expected_ch, expected_sr) in &files {
        let path = dir.join(file);
        let pcm =
            decode::load_audio(&path).unwrap_or_else(|e| panic!("Failed to decode {file}: {e}"));
        assert_eq!(pcm.channels, *expected_ch, "{file}: channels mismatch");
        assert_eq!(
            pcm.sample_rate, *expected_sr,
            "{file}: sample_rate mismatch"
        );
        assert!(pcm.validate(), "{file}: PCM should be valid");
    }
}

// --- resolve_audio_path fallback ---

#[test]
fn test_resolve_audio_path_format_fallback() {
    let dir = test_audio_dir();

    // Search for a .wav that doesn't exist, but .flac does
    let result = decode::resolve_audio_path(&dir, "sine_440_mono.wav");
    // sine_440_mono.wav doesn't exist, but sine_440_mono.flac does
    assert!(result.is_some(), "Should find fallback format");
    let found = result.unwrap();
    let ext = found.extension().unwrap().to_str().unwrap();
    assert!(
        ext == "flac" || ext == "ogg" || ext == "mp3",
        "Should fall back to an existing format, got .{ext}"
    );
}

// --- PCM sample rate conversion with real audio ---

#[test]
fn test_sample_rate_conversion_real_audio() {
    let path = test_audio_dir().join("sine_440_16bit_mono.wav");
    let pcm = decode::load_audio(&path).expect("Failed to decode WAV");

    // Resample from 44100 to 22050
    let resampled = pcm.change_sample_rate(22050);
    assert_eq!(resampled.sample_rate, 22050);
    assert_eq!(resampled.channels, 1);

    // Frame count should be approximately half
    let ratio = pcm.num_frames() as f64 / resampled.num_frames() as f64;
    assert!(
        (ratio - 2.0).abs() < 0.01,
        "Resample ratio should be ~2.0, got {ratio}"
    );

    // Resampled audio should still look like a sine wave
    assert_sine_wave_like(&resampled, "Resampled WAV");
}

// --- PCM channel conversion with real audio ---

#[test]
fn test_channel_conversion_real_audio() {
    let path = test_audio_dir().join("sine_440_16bit_mono.wav");
    let mono = decode::load_audio(&path).expect("Failed to decode WAV");

    // Convert mono to stereo
    let stereo = mono.change_channels(2);
    assert_eq!(stereo.channels, 2);
    assert_eq!(stereo.num_frames(), mono.num_frames());

    // Both channels should have the same data (duplicated from mono)
    for i in 0..stereo.num_frames() {
        let left = stereo.samples[i * 2];
        let right = stereo.samples[i * 2 + 1];
        assert!(
            (left - right).abs() < 1e-6,
            "Stereo channels should be identical at frame {i}"
        );
        assert!(
            (left - mono.samples[i]).abs() < 1e-6,
            "Stereo left should match mono at frame {i}"
        );
    }
}
